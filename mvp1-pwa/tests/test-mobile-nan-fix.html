<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mobile NaN Fix - TDD Tests</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }

    h1 {
      color: #2c3e50;
      border-bottom: 3px solid #3498db;
      padding-bottom: 10px;
    }

    .test-section {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .test-case {
      margin: 15px 0;
      padding: 15px;
      border-left: 4px solid #ccc;
      background: #f9f9f9;
    }

    .test-case.pass {
      border-left-color: #27ae60;
      background: #e8f8f5;
    }

    .test-case.fail {
      border-left-color: #e74c3c;
      background: #fadbd8;
    }

    .test-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .test-result {
      font-size: 14px;
      color: #555;
    }

    .summary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin-top: 30px;
    }

    .summary h2 {
      margin-top: 0;
    }

    .stats {
      display: flex;
      justify-content: space-around;
      margin-top: 20px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-number {
      font-size: 48px;
      font-weight: bold;
      display: block;
    }

    .error-message {
      color: #c0392b;
      background: #f8d7da;
      padding: 10px;
      border-radius: 4px;
      margin-top: 10px;
      font-family: monospace;
      font-size: 12px;
      white-space: pre-wrap;
    }

    .code-block {
      background: #282c34;
      color: #abb2bf;
      padding: 12px;
      border-radius: 4px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <h1>üêõ Mobile NaN Fix - TDD Tests</h1>
  <p><strong>Purpose:</strong> Verify that NaN values cannot enter the learning system on mobile devices</p>
  <p><strong>Issue:</strong> Android mobile users reported NaN values in exported learning data</p>
  <p><strong>Fix:</strong> Added defensive validation in handleSelection(), parseInt() calls, and setWeight()</p>

  <div id="test-results"></div>
  <div id="summary" class="summary" style="display: none;"></div>

  <!-- Import UserDB -->
  <script type="module">
    import { UserDB } from '../js/user_db_indexeddb.js';

    // Test framework
    const testResults = [];
    let currentSection = '';

    function section(name) {
      currentSection = name;
      console.log(`\n=== ${name} ===`);
    }

    async function it(testName, testFn) {
      const fullName = `${currentSection} - ${testName}`;
      try {
        await testFn();
        testResults.push({ name: fullName, passed: true });
        console.log(`‚úÖ ${fullName}`);
      } catch (error) {
        testResults.push({ name: fullName, passed: false, error: error.message });
        console.error(`‚ùå ${fullName}:`, error.message);
      }
    }

    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, got ${actual}`);
      }
    }

    // Mock handleSelection with validation (simulating the fix)
    function mockHandleSelection(index, currentPage = 0) {
      // üêõ Mobile Fix: Defensive validation to prevent NaN
      if (typeof index !== 'number' || isNaN(index) || index < 0) {
        console.error(`[WebDaYi] Invalid index in handleSelection: ${index} (type: ${typeof index})`);
        throw new Error(`Invalid index: ${index}`);
      }

      if (typeof currentPage !== 'number' || isNaN(currentPage)) {
        console.error(`[WebDaYi] Invalid currentPage: ${currentPage}, resetting to 0`);
        currentPage = 0;
      }

      const actualIndex = currentPage * 6 + index;

      // üêõ Mobile Fix: Validate actualIndex before creating learning data
      if (isNaN(actualIndex) || actualIndex < 0) {
        console.error(`[WebDaYi] Invalid actualIndex: ${actualIndex}`);
        throw new Error(`Invalid actualIndex: ${actualIndex}`);
      }

      return actualIndex;
    }

    // Mock parseInt validation (simulating the fix in click handlers)
    function mockParseIndex(datasetIndex) {
      const index = parseInt(datasetIndex, 10);

      // üêõ Mobile Fix: Validate parsed index
      if (isNaN(index)) {
        console.error(`[WebDaYi] Failed to parse index from dataset: "${datasetIndex}"`);
        throw new Error(`Failed to parse index: ${datasetIndex}`);
      }

      return index;
    }

    // Run tests
    async function runTests() {
      console.log('üß™ Starting Mobile NaN Fix Tests...\n');

      // Section 1: handleSelection Validation Tests
      section('Section 1: handleSelection Validation');

      await it('Valid index (0) should work', async () => {
        const result = mockHandleSelection(0);
        assertEqual(result, 0, 'Should return 0 for index 0');
      });

      await it('Valid index (5) should work', async () => {
        const result = mockHandleSelection(5);
        assertEqual(result, 5, 'Should return 5 for index 5');
      });

      await it('NaN index should be rejected', async () => {
        try {
          mockHandleSelection(NaN);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid index'), 'Should reject NaN index');
        }
      });

      await it('Undefined index should be rejected', async () => {
        try {
          mockHandleSelection(undefined);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid index'), 'Should reject undefined index');
        }
      });

      await it('String index should be rejected', async () => {
        try {
          mockHandleSelection('5');
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid index'), 'Should reject string index');
        }
      });

      await it('Negative index should be rejected', async () => {
        try {
          mockHandleSelection(-1);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid index'), 'Should reject negative index');
        }
      });

      await it('Valid index with currentPage should work', async () => {
        const result = mockHandleSelection(2, 1);
        assertEqual(result, 8, 'Should return 8 (1*6 + 2)');
      });

      await it('NaN currentPage should be handled', async () => {
        const result = mockHandleSelection(2, NaN);
        assertEqual(result, 2, 'Should reset currentPage to 0 and return 2');
      });

      // Section 2: parseInt Validation Tests
      section('Section 2: parseInt Validation');

      await it('Valid dataset.index "0" should parse', async () => {
        const result = mockParseIndex('0');
        assertEqual(result, 0, 'Should parse "0" to 0');
      });

      await it('Valid dataset.index "5" should parse', async () => {
        const result = mockParseIndex('5');
        assertEqual(result, 5, 'Should parse "5" to 5');
      });

      await it('Invalid dataset.index "abc" should be rejected', async () => {
        try {
          mockParseIndex('abc');
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Failed to parse'), 'Should reject non-numeric string');
        }
      });

      await it('Undefined dataset.index should be rejected', async () => {
        try {
          mockParseIndex(undefined);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Failed to parse'), 'Should reject undefined');
        }
      });

      await it('Null dataset.index should be rejected', async () => {
        try {
          mockParseIndex(null);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Failed to parse'), 'Should reject null');
        }
      });

      // Section 3: UserDB setWeight Validation Tests
      section('Section 3: UserDB setWeight Validation');

      const userDB = new UserDB();
      await userDB.open();

      await it('Valid weight (1.0) should be accepted', async () => {
        await userDB.setWeight('^', 'Êòì', 1.0);
        const weight = await userDB.getWeight('^', 'Êòì');
        assertEqual(weight, 1.0, 'Should store weight 1.0');
      });

      await it('Valid weight (0) should be accepted', async () => {
        await userDB.setWeight('^', 'Âú®', 0);
        const weight = await userDB.getWeight('^', 'Âú®');
        assertEqual(weight, 0, 'Should store weight 0');
      });

      await it('Valid negative weight should be accepted', async () => {
        await userDB.setWeight('^', 'Â§ß', -0.5);
        const weight = await userDB.getWeight('^', 'Â§ß');
        assertEqual(weight, -0.5, 'Should store negative weight');
      });

      await it('NaN weight should be rejected', async () => {
        try {
          await userDB.setWeight('^', 'Â§©', NaN);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid weight'), 'Should reject NaN weight');
        }
      });

      await it('Infinity weight should be rejected', async () => {
        try {
          await userDB.setWeight('^', 'Êòé', Infinity);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid weight'), 'Should reject Infinity weight');
        }
      });

      await it('String weight should be rejected', async () => {
        try {
          await userDB.setWeight('^', 'Â•Ω', '1.0');
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid weight'), 'Should reject string weight');
        }
      });

      await it('Undefined weight should be rejected', async () => {
        try {
          await userDB.setWeight('^', 'ÁöÑ', undefined);
          throw new Error('Should have thrown error');
        } catch (error) {
          assert(error.message.includes('Invalid weight'), 'Should reject undefined weight');
        }
      });

      // Clean up
      await userDB.clearAll();

      // Section 4: Integration Tests
      section('Section 4: Integration Tests');

      await it('Complete flow with valid data should work', async () => {
        // Simulate mobile click event
        const datasetIndex = '2';
        const index = mockParseIndex(datasetIndex);
        const actualIndex = mockHandleSelection(index, 0);

        // Simulate learning data creation
        const learningData = {
          selectedRank: actualIndex
        };

        // Verify no NaN
        assert(!isNaN(learningData.selectedRank), 'selectedRank should not be NaN');
        assertEqual(learningData.selectedRank, 2, 'selectedRank should be 2');

        // Simulate UserDB storage
        await userDB.setWeight('^', 'Ê∏¨', learningData.selectedRank);
        const stored = await userDB.getWeight('^', 'Ê∏¨');
        assertEqual(stored, 2, 'Should store and retrieve correctly');
      });

      await it('Flow with invalid dataset should be caught early', async () => {
        try {
          // Simulate mobile click event with corrupt data
          const datasetIndex = undefined;
          const index = mockParseIndex(datasetIndex);
          // Should not reach here
          throw new Error('Should have been caught by mockParseIndex');
        } catch (error) {
          assert(error.message.includes('Failed to parse'), 'Should be caught at parse stage');
        }
      });

      await it('Flow with NaN from calculation should be caught', async () => {
        try {
          // Simulate case where NaN comes from calculation
          const index = NaN;
          mockHandleSelection(index);
          // Should not reach here
          throw new Error('Should have been caught by handleSelection');
        } catch (error) {
          assert(error.message.includes('Invalid index'), 'Should be caught at handleSelection');
        }
      });

      // Render results
      renderResults();
    }

    function renderResults() {
      const container = document.getElementById('test-results');
      const passed = testResults.filter(t => t.passed).length;
      const failed = testResults.filter(t => !t.passed).length;
      const total = testResults.length;

      // Render individual test results
      const sections = {};
      testResults.forEach(result => {
        const [section, ...rest] = result.name.split(' - ');
        const testName = rest.join(' - ');

        if (!sections[section]) {
          sections[section] = [];
        }
        sections[section].push({ name: testName, ...result });
      });

      let html = '';
      Object.keys(sections).forEach(sectionName => {
        html += `<div class="test-section">`;
        html += `<h2>${sectionName}</h2>`;
        sections[sectionName].forEach(test => {
          html += `<div class="test-case ${test.passed ? 'pass' : 'fail'}">`;
          html += `<div class="test-name">${test.passed ? '‚úÖ' : '‚ùå'} ${test.name}</div>`;
          if (!test.passed) {
            html += `<div class="error-message">${test.error}</div>`;
          }
          html += `</div>`;
        });
        html += `</div>`;
      });

      container.innerHTML = html;

      // Render summary
      const summaryDiv = document.getElementById('summary');
      summaryDiv.style.display = 'block';
      summaryDiv.innerHTML = `
        <h2>üìä Test Summary</h2>
        <div class="stats">
          <div class="stat-item">
            <span class="stat-number">${passed}</span>
            <span>Passed</span>
          </div>
          <div class="stat-item">
            <span class="stat-number">${failed}</span>
            <span>Failed</span>
          </div>
          <div class="stat-item">
            <span class="stat-number">${total}</span>
            <span>Total</span>
          </div>
        </div>
        <p style="margin-top: 20px; font-size: 18px;">
          ${failed === 0 ? 'üéâ All tests passed! Mobile NaN issue is fixed.' : '‚ö†Ô∏è Some tests failed. Please review.'}
        </p>
      `;

      console.log(`\nüìä Summary: ${passed}/${total} tests passed`);
    }

    // Run tests when page loads
    runTests().catch(error => {
      console.error('Test execution failed:', error);
    });
  </script>
</body>
</html>
