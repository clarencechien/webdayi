# **產品需求文件 (PRD)：WebDaYi (網頁大易輸入法)**

| 文件版本 | 1.1 (MVP 2a 路線) |
| :---- | :---- |
| **建立日期** | 2025-11-06 |
| **專案負責人** | (您的名字) |
| **狀態** | 草案 |

## **1\. 概述 (Overview)**

### **1.1. 問題陳述 (Problem)**

1. **大易輸入法**的使用者群體雖然穩定，但可選用的現代輸入法工具相對較少。  
2. 現有的高效能輸入法（如 Rime）功能強大，但**設定檔 (config) 複雜**，客製化門檻高，且「全家桶」架構對只想用單一輸入法的使用者來說過於笨重。  
3. 使用者（開發者本人）希望擁有一個**完全可控、輕量、且能依據個人習慣高度客製化**的輸入法，並希望它能以現代 Web 技術為核心，以便未來擴展。

### **1.2. 解決方案 (Solution)**

打造一個名為「**WebDaYi**」的輕量級、網頁優先 (Web-First) 的大易輸入法。本專案將寄生 (piggyback) 於 Rime 現有的開源大易**資料**之上，但**自行實作**一個更簡單、更現代的**核心引擎**與**瀏覽器整合**外殼。

### **1.3. 專案願景 (Vision)**

提供一個啟動快、延遲低、易於客製化、且最終能實現個人化學習（N-gram、動態詞庫、雲同步）的**瀏覽器內**原生輸入體驗。

## **2\. 專案目標 & 範圍 (Goals & Scope)**

### **2.1. 核心目標**

* **驗證可行性：** 證明 Web 技術（JS）足以承擔高效能輸入法所需的核心運算（查表、排序）。  
* **提供價值：** 為大易使用者（特別是重度瀏覽器使用者）提供一個「免設定、雲同步」的智能輸入選項。

### **2.2. 成功指標 (Success Metrics)**

* **MVP 1：** 核心查表邏輯 100% 準確。使用者能在 3 分鐘內，透過「輸入-選字-複製」流程，無錯誤地完成 100 字的段落撰寫。  
* **MVP 2a：** 「就地注入」(In-Place Injection) 延遲低於 100ms。外掛能在 3 個以上的主流 Web 應用（例如：Gmail, Notion Web, Google Docs）的輸入框中無縫運作。

### **2.3. 目標使用者 (Target Audience)**

* **P0 (主要)：** 開發者本人。一個熟悉大易、重度使用瀏覽器（Web Apps）、且渴望工具能「情境感知」和「雲同步」的超級使用者。  
* **P1 (次要)：** 其他大易輸入法使用者，他們的主要工作和溝通都在瀏覽器中完成。

## **3\. 專案路線圖 (Project Roadmap)**

本專案將拆分為兩個緊密相連的 MVP 階段，以分離「核心邏輯」與「瀏覽器整合」的複雜性。

1. **MVP 1：純網站核心引擎 (The Core Engine)**  
   * **目標：** 在瀏覽器沙盒中，100% 驗證與除錯「輸入-查詢-排序-組字」的核心演算法。  
   * **交付物：** 一個靜態網頁 (index.html \+ core\_logic.js)。  
2. **MVP 2a：「瀏覽器整合」外掛 (The Browser Plugin)**  
   * **目標：** 重用 MVP 1 的**全部**核心程式碼，將其打包成一個「Chrome 擴充功能」，在瀏覽器內提供無縫的「就地」輸入體驗。  
   * **交付物：** 一個可上架的 Chrome 擴充功能 .zip 檔。

## **4\. 共通架構：資料管線 (Data Pipeline)**

此為兩個 MVP 的**共同依賴項**，必須最先完成。

| ID | 需求 | 備註 |
| :---- | :---- | :---- |
| **C.1** | **Rime 資料轉換器** | 必須建立一個一次性的轉換腳本 (Python 或 Node.js)。 |
| **C.2** | **讀取 Rime 碼表** | 腳本必須能讀取 Rime 的 dayi.dict.yaml (大易詞典檔)。 |
| **C.3** | **輸出 dayi\_db.json** | 腳本必須輸出一份 json 檔案，作為 Web App 的核心資料庫。 |
| **C.4** | **JSON 資料結構** | 輸出的 JSON 必須採用「**以碼為 Key**」的結構，以實現 O(1) 查詢。 **格式範例：** { "4jp": \[ { "char": "易", "freq": 80 }, { "char": "義", "freq": 70 } \], "a": \[ { "char": "大", "freq": 100 } \] ... } |

## **5\. MVP 1：「純網站」核心引擎 PRD**

**目標：** 在瀏覽器沙盒中，專注驗證核心演算法。

| ID | 功能 | 使用者故事 (User Story) | 驗收標準 (AC) |
| :---- | :---- | :---- | :---- |
| **MVP1.1** | **資料載入** | 作為使用者，我希望頁面載入時，能快速讀取大易碼表資料庫。 | 1\. core\_logic.js 必須使用 fetch API 讀取 dayi\_db.json。 2\. 必須將 JSON 資料轉換為 JavaScript Map 物件並存入記憶體，以供快速查詢。 |
| **MVP1.2** | **按鍵輸入** | 作為使用者，我希望在「輸入框」中輸入大易碼 4jp。 | 1\. 頁面需有一個 \<input\> 元素。 2\. JS 必須監聽 input 事件。 |
| **MVP1.3** | **查詢與排序** | 作為使用者，我輸入 4jp 後，希望能立刻看到「易」和「義」。 | 1\. JS 必須即時查詢 Map.get('4jp')。 2\. 必須依照 dayi\_db.json 中提供的 freq (詞頻) **由高到低**排序候選字。 |
| **MVP1.4** | **候選字渲染** | 作為使用者，我希望候選字依序顯示 1\. 易 2\. 義。 | 1\. 頁面需有一個 \<div\> (候選區)。 2\. 排序後的候選字必須被動態渲染到此 \<div\> 中，並包含數字編號。 |
| **MVP1.5** | **選字與組字** | 作為使用者，我希望能按下數字鍵 1 來選擇「易」。 | 1\. JS 必須監聽 keydown 事件 (捕捉 1-9)。 2\. 選字後，「易」字必須被添加(append)到一個「輸出緩衝區」(\<textarea\>) 中。 3\. 選字後，「輸入框」必須自動清空。 |
| **MVP1.6** | **剪貼簿輸出** | 作為使用者，我組好一句話後，希望能點擊「複製」按鈕。 | 1\. 頁面需有一個「複製」按鈕。 2\. 點擊後，必須呼叫 navigator.clipboard.writeText()，複製「輸出緩衝區」的**所有**內容。 |

## **6\. MVP 2a：「瀏覽器整合」外掛 PRD**

**目標：** 重用 MVP 1 核心，將其打包成一個無縫的「瀏覽器內」原生輸入法。

### **6.1. 功能需求 (Functional Requirements)**

| ID | 功能 | 使用者故事 (User Story) | 驗收標準 (AC) |
| :---- | :---- | :---- | :---- |
| **MVP2a.1** | **核心重用 (P0)** | 作為開發者，我希望能 100% 重用 MVP 1 的核心邏輯。 | 1\. MVP 1 的 core\_logic.js (查詢、排序) 應被重構為一個可獨立呼叫的模組。 2\. dayi\_db.json 應由 background.js 載入。 |
| **MVP2a.2** | **外掛結構** | 作為開發者，我需要一個標準的 Manifest V3 外掛結構。 | 1\. 必須包含 manifest.json (V3)。 2\. 必須包含 background.js (Service Worker)。 3\. 必須包含 content.js (內容腳本)。 |
| **MVP2a.3** | **權限請求** | 作為使用者，我希望外掛只請求最必要的權限。 | 1\. manifest.json 必須請求 "storage" (用於個人詞庫)。 2\. 必須請求 "scripting" 和 "activeTab" 來實現動態注入 content.js (這是比 \<all\_urls\> 更安全的作法)。 |
| **MVP2a.4** | **核心載入** | 作為使用者，我希望輸入法核心能在瀏覽器啟動時就準備好。 | 1\. background.js 必須在 onInstalled 或 onStartup 事件時，fetch dayi\_db.json 並將其載入記憶體的 Map 物件。 |
| **MVP2a.5** | **輸入攔截** | 作為使用者，當我在 Gmail 輸入框中打字時，我希望 WebDaYi 能被觸發。 | 1\. content.js (被注入後) 必須能偵測頁面上的可輸入區域 (如 \<textarea\>, contentEditable)。 2\. 必須監聽 keydown 事件，並能**攔截** (e.g., event.preventDefault()) 大易碼 (如 4jp)。 |
| **MVP2a.6** | **動態 UI** | 作為使用者，我希望候選字視窗能出現在我打字的地方。 | 1\. content.js 必須**動態建立**一個 \<div\> (候選字視窗)。 2\. 此 \<div\> 必須透過計算 window.getSelection() 或 element.caretPosition 來精確**定位**在游標附近。 |
| **MVP2a.7** | **訊息通訊** | (背後運作) 內容腳本需要向背景腳本請求查詢。 | 1\. content.js 必須使用 chrome.runtime.sendMessage 發送查詢請求 (e.g., { type: "query", code: "4jp" })。 2\. background.js 必須監聽 onMessage 事件，處理查詢並回傳結果。 |
| **MVP2a.8** | **就地注入 (P0)** | 作為使用者，我按下 1 選字後，「易」字必須**立刻**出現在我的 Gmail 中。 | 1\. content.js 收到選字指令 (e.g., 按下 1)。 2\. 必須使用 document.execCommand('insertText', ...) 或直接操作 textarea.value 將「易」字**就地插入**到游標位置。 3\. 插入後，動態 UI \<div\> 必須被銷毀或隱藏。 |

### **6.2. 非功能需求 (Non-Functional)**

* **效能：** 從按鍵 (e.g., p) \-\> 攔截 \-\> 查詢 \-\> 候選字渲染，整個過程必須低於 100ms，達到體感無延遲。  
* **相容性：** content.js 必須能正確應對**富文本編輯器** (如 Google Docs, Notion) 和**Shadow DOM** (某些網頁元件)。  
* **穩定性：** content.js 注入的 CSS 和 JS **不得**與宿主網頁的樣式或功能衝突 (需使用 CSS 隔離策略)。

## **7\. 未來展望 (MVP 2a+ 路線)**

MVP 2a 的架構為我們解鎖了獨特的「超能力」，這些將是 MVP 2 (Electron) 路線永遠無法實現的。

* **MVP2a.plus.1 (領域感知)：** content.js 偵測 window.location.hostname，並通知 background.js 動態加權或載入**特定領域的 N-gram 表** (例如在 github.com 優先顯示程式碼相關詞彙)。  
* **MVP2a.plus.2 (雲同步個人詞庫)：** background.js 使用 chrome.storage.sync API 來儲存使用者的動態詞庫。使用者在 A 電腦學會的新詞，會自動同步到 B 電腦的 Chrome。  
* **MVP2a.plus.3 (動態學習)：** 實現完整的 N-gram 統計與個人化機率調整，並將結果存入 chrome.storage.sync。
