<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phase 1 Integration Tests - Learning Workflow</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #4CAF50;
      padding-bottom: 10px;
    }
    .test-suite {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .test-suite h2 {
      color: #4CAF50;
      margin-top: 0;
    }
    .test-case {
      margin: 15px 0;
      padding: 15px;
      border-left: 4px solid #ddd;
      background: #fafafa;
    }
    .test-case.pass {
      border-left-color: #4CAF50;
      background: #f1f8f4;
    }
    .test-case.fail {
      border-left-color: #f44336;
      background: #fef1f1;
    }
    .test-case.pending {
      border-left-color: #FFC107;
      background: #fffbf0;
    }
    .test-name {
      font-weight: bold;
      margin-bottom: 8px;
    }
    .test-result {
      font-size: 14px;
      color: #666;
    }
    .test-error {
      color: #f44336;
      font-family: monospace;
      font-size: 12px;
      background: #fff;
      padding: 10px;
      border-radius: 4px;
      margin-top: 8px;
      white-space: pre-wrap;
    }
    .summary {
      background: #333;
      color: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      font-size: 18px;
    }
    .summary .pass { color: #4CAF50; font-weight: bold; }
    .summary .fail { color: #f44336; font-weight: bold; }
    .summary .pending { color: #FFC107; font-weight: bold; }
    .test-code {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      margin-top: 8px;
    }
    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>üß™ Phase 1 Integration Tests - Learning Workflow</h1>

  <div class="summary" id="summary">
    <div class="loading">‚è≥ Running tests...</div>
  </div>

  <div id="test-results"></div>

  <!-- Load dependencies -->
  <script src="../js/viterbi_module.js"></script>

  <script type="module">
    // ============================================================================
    // Import Dependencies
    // ============================================================================

    import { UserDB } from '../js/user_db_indexeddb.js';

    // Make UserDB available globally for tests
    window.UserDB = UserDB;

    // ============================================================================
    // Test Framework
    // ============================================================================

    const testResults = [];
    let currentSuite = null;

    function describe(suiteName, fn) {
      console.log(`\nüìã [TEST SUITE] ${suiteName}`);
      console.log(`${'='.repeat(60)}`);
      currentSuite = { name: suiteName, tests: [] };
      fn();
      renderTestSuite(currentSuite);
      console.log(`${'='.repeat(60)}\n`);
    }

    async function it(testName, fn) {
      const test = { name: testName, status: 'pending', error: null };
      currentSuite.tests.push(test);

      console.log(`üß™ [TEST START] ${currentSuite.name} ‚Üí ${testName}`);

      try {
        await fn();
        test.status = 'pass';
        test.result = '‚úì Passed';
        console.log(`‚úÖ [TEST PASS] ${testName}`);
      } catch (error) {
        test.status = 'fail';
        test.error = error.message;
        test.result = `‚úó Failed: ${error.message}`;
        console.error(`‚ùå [TEST FAIL] ${testName}`);
        console.error(`   Error: ${error.message}`);
        console.error(`   Stack:`, error.stack);
      }

      testResults.push(test);
      updateTestCase(test);
    }

    function expect(actual) {
      return {
        toBe(expected) {
          console.log(`   Checking: ${JSON.stringify(actual)} === ${JSON.stringify(expected)}`);
          if (actual !== expected) {
            throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
          }
        },
        toEqual(expected) {
          console.log(`   Checking equal:`, { actual, expected });
          if (JSON.stringify(actual) !== JSON.stringify(expected)) {
            throw new Error(`Expected ${JSON.stringify(expected)}, got ${JSON.stringify(actual)}`);
          }
        },
        toBeDefined() {
          console.log(`   Checking defined:`, actual);
          if (actual === undefined || actual === null) {
            throw new Error(`Expected value to be defined, got ${actual}`);
          }
        },
        toBeTruthy() {
          console.log(`   Checking truthy:`, actual);
          if (!actual) {
            throw new Error(`Expected truthy value, got ${actual}`);
          }
        },
        toBeGreaterThan(expected) {
          console.log(`   Checking: ${actual} > ${expected}`);
          if (actual <= expected) {
            throw new Error(`Expected ${actual} to be greater than ${expected}`);
          }
        },
        toContain(expected) {
          console.log(`   Checking contains:`, { actual, expected });
          if (!actual.includes(expected)) {
            throw new Error(`Expected ${JSON.stringify(actual)} to contain ${JSON.stringify(expected)}`);
          }
        },
        toBeInstanceOf(expected) {
          console.log(`   Checking instanceof:`, { actual: typeof actual, expected: expected.name });
          if (!(actual instanceof expected)) {
            throw new Error(`Expected instance of ${expected.name}, got ${typeof actual}`);
          }
        }
      };
    }

    function renderTestSuite(suite) {
      const container = document.getElementById('test-results');
      const suiteDiv = document.createElement('div');
      suiteDiv.className = 'test-suite';
      suiteDiv.id = `suite-${suite.name.replace(/\s+/g, '-')}`;

      const title = document.createElement('h2');
      title.textContent = suite.name;
      suiteDiv.appendChild(title);

      suite.tests.forEach((test, index) => {
        const testDiv = document.createElement('div');
        testDiv.className = `test-case ${test.status}`;
        testDiv.id = `test-${currentSuite.tests.length - 1}-${index}`;

        const nameDiv = document.createElement('div');
        nameDiv.className = 'test-name';
        nameDiv.textContent = test.name;
        testDiv.appendChild(nameDiv);

        const resultDiv = document.createElement('div');
        resultDiv.className = 'test-result';
        resultDiv.textContent = test.result || '‚è≥ Running...';
        testDiv.appendChild(resultDiv);

        if (test.error) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'test-error';
          errorDiv.textContent = test.error;
          testDiv.appendChild(errorDiv);
        }

        suiteDiv.appendChild(testDiv);
      });

      container.appendChild(suiteDiv);
    }

    function updateTestCase(test) {
      // Find the test div and update it
      const testDivs = document.querySelectorAll('.test-case.pending');
      if (testDivs.length > 0) {
        const testDiv = testDivs[0];
        testDiv.className = `test-case ${test.status}`;
        const resultDiv = testDiv.querySelector('.test-result');
        resultDiv.textContent = test.result;

        if (test.error) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'test-error';
          errorDiv.textContent = test.error;
          testDiv.appendChild(errorDiv);
        }
      }

      updateSummary();
    }

    function updateSummary() {
      const summary = document.getElementById('summary');
      const passed = testResults.filter(t => t.status === 'pass').length;
      const failed = testResults.filter(t => t.status === 'fail').length;
      const total = testResults.length;

      summary.innerHTML = `
        <div>
          <span class="pass">${passed} passed</span> /
          <span class="fail">${failed} failed</span> /
          ${total} total
        </div>
        <div style="margin-top: 10px; font-size: 14px;">
          ${failed === 0 ? '‚úÖ All tests passed!' : '‚ö†Ô∏è Some tests failed'}
        </div>
      `;
    }

    // ============================================================================
    // Mock Data
    // ============================================================================

    // Convert mock data to Map (Viterbi expects Map, not plain object)
    const mockDayiDb = new Map([
      ['4jp', [{ char: 'Êòì', freq: 80 }, { char: 'Áæ©', freq: 70 }]],
      ['ad', [{ char: 'Âú®', freq: 90 }, { char: 'ÂÜç', freq: 85 }]],
      ['a', [{ char: 'Â§ß', freq: 100 }]]
    ]);

    const mockNgramDb = {
      version: '2.0',
      smoothing_alpha: 0.1,
      vocab_size: 100,
      total_chars: 1000,
      unigrams: {
        'Êòì': 0.05,
        'Áæ©': 0.03,
        'Âú®': 0.08,
        'ÂÜç': 0.04,
        'Â§ß': 0.10
      },
      unigram_counts: {
        'Êòì': 50,
        'Áæ©': 30,
        'Âú®': 80,
        'ÂÜç': 40,
        'Â§ß': 100
      },
      bigrams: {
        'ÊòìÂú®': 0.6,
        'ÊòìÂÜç': 0.1,
        'Áæ©Âú®': 0.2,
        'Áæ©ÂÜç': 0.1
      },
      bigram_counts: {
        'ÊòìÂú®': 30,
        'ÊòìÂÜç': 5,
        'Áæ©Âú®': 10,
        'Áæ©ÂÜç': 5
      }
    };

    // ============================================================================
    // Test Suites
    // ============================================================================

    async function runAllTests() {
      // Suite 1: UserDB Initialization
      describe('Category 1: UserDB Initialization (5 tests)', async () => {
        await it('UserDB class should be defined', async () => {
          expect(typeof UserDB).toBe('function');
        });

        await it('UserDB instance should be creatable', async () => {
          const db = new UserDB();
          expect(db).toBeInstanceOf(UserDB);
        });

        await it('UserDB should open successfully', async () => {
          const db = new UserDB();
          await db.open();
          expect(db.db).toBeDefined();
          await db.close();
        });

        await it('UserDB should have required methods', async () => {
          const db = new UserDB();
          expect(typeof db.getWeight).toBe('function');
          expect(typeof db.setWeight).toBe('function');
          expect(typeof db.getAllWeights).toBe('function');
        });

        await it('UserDB should return 0 for unlearned patterns', async () => {
          // Use unique database name to ensure fresh start
          const db = new UserDB('test_fresh_db_' + Date.now());
          await db.open();
          const weight = await db.getWeight('Êòì', 'Âú®');
          expect(weight).toBe(0);
          await db.close();
          // Clean up - delete the test database
          await db.deleteDatabase();
        });
      });

      // Suite 2: Viterbi Integration with UserDB
      describe('Category 2: Viterbi Integration with UserDB (6 tests)', async () => {
        await it('viterbiWithUserDB function should exist', async () => {
          expect(typeof viterbiWithUserDB).toBe('function');
        });

        await it('viterbiWithUserDB should accept UserDB parameter', async () => {
          const db = new UserDB();
          await db.open();

          const result = await viterbiWithUserDB(['4jp', 'ad'], mockDayiDb, mockNgramDb, db);
          expect(result).toBeDefined();
          expect(result.sentence).toBeDefined();

          await db.close();
        });

        await it('viterbiWithUserDB should work with null UserDB (graceful degradation)', async () => {
          const result = await viterbiWithUserDB(['4jp', 'ad'], mockDayiDb, mockNgramDb, null);
          expect(result).toBeDefined();
          expect(result.sentence).toBeDefined();
        });

        await it('viterbiWithUserDB should use learned weights in scoring', async () => {
          // Use fresh database to ensure test isolation
          const db = new UserDB('test_learned_weights_' + Date.now());
          await db.open();

          // Set a strong preference: Êòì‚ÜíÂú® (boost it significantly)
          await db.setWeight('Êòì', 'Âú®', 10.0);  // Large weight to ensure it wins

          const result = await viterbiWithUserDB(['4jp', 'ad'], mockDayiDb, mockNgramDb, db);
          expect(result.sentence).toContain('ÊòìÂú®');

          await db.close();
          await db.deleteDatabase();
        });

        await it('viterbiWithUserDB result should match standard viterbi structure', async () => {
          const db = new UserDB();
          await db.open();

          const result = await viterbiWithUserDB(['4jp'], mockDayiDb, mockNgramDb, db);
          expect(result.sentence).toBeDefined();
          expect(result.chars).toBeDefined();
          expect(result.score).toBeDefined();
          expect(Array.isArray(result.chars)).toBeTruthy();

          await db.close();
        });

        await it('viterbiWithUserDB should handle empty codes gracefully', async () => {
          const db = new UserDB();
          await db.open();

          try {
            const result = await viterbiWithUserDB([], mockDayiDb, mockNgramDb, db);
            // Should either return null or throw error - both are acceptable
            expect(true).toBeTruthy();
          } catch (error) {
            // Error is acceptable for empty input
            expect(true).toBeTruthy();
          }

          await db.close();
        });
      });

      // Suite 3: Learning Detection
      describe('Category 3: Learning Detection (5 tests)', async () => {
        await it('detectLearning function should exist', async () => {
          expect(typeof detectLearning).toBe('function');
        });

        await it('detectLearning should detect single character correction', async () => {
          const prediction = 'ÊòìÂú®';
          const userSelection = 'Áæ©Âú®';

          const learningData = detectLearning(prediction, userSelection);
          expect(learningData.length).toBe(1);
          expect(learningData[0].from).toBe('Êòì');
          expect(learningData[0].to).toBe('Áæ©');
        });

        await it('detectLearning should return empty for identical strings', async () => {
          const prediction = 'ÊòìÂú®';
          const userSelection = 'ÊòìÂú®';

          const learningData = detectLearning(prediction, userSelection);
          expect(learningData.length).toBe(0);
        });

        await it('detectLearning should detect multiple corrections', async () => {
          const prediction = 'ÊòìÂú®Â§ß';
          const userSelection = 'Áæ©ÂÜçÂ§ß';

          const learningData = detectLearning(prediction, userSelection);
          expect(learningData.length).toBe(2);
        });

        await it('detectLearning should include bigram context', async () => {
          const prediction = 'Â§ßÊòìÂú®';
          const userSelection = 'Â§ßÁæ©Âú®';

          const learningData = detectLearning(prediction, userSelection);
          expect(learningData[0].prevChar).toBe('Â§ß');
          expect(learningData[0].to).toBe('Áæ©');
        });
      });

      // Suite 4: Learning Persistence
      describe('Category 4: Learning Persistence (5 tests)', async () => {
        await it('applyLearning function should exist', async () => {
          expect(typeof applyLearning).toBe('function');
        });

        await it('applyLearning should persist learning to UserDB', async () => {
          const db = new UserDB();
          await db.open();

          const learningData = [{
            prevChar: 'Êòì',
            to: 'Âú®',
            from: 'ÂÜç',
            weight: 1.0
          }];

          await applyLearning(learningData, db);

          const weight = await db.getWeight('Êòì', 'Âú®');
          expect(weight).toBeGreaterThan(0);

          await db.close();
        });

        await it('applyLearning should increment existing weights', async () => {
          const db = new UserDB();
          await db.open();

          const learningData = [{
            prevChar: 'Êòì',
            to: 'Âú®',
            from: 'ÂÜç',
            weight: 1.0
          }];

          // Apply learning twice
          await applyLearning(learningData, db);
          const weight1 = await db.getWeight('Êòì', 'Âú®');

          await applyLearning(learningData, db);
          const weight2 = await db.getWeight('Êòì', 'Âú®');

          expect(weight2).toBeGreaterThan(weight1);

          await db.close();
        });

        await it('applyLearning should handle multiple learning points', async () => {
          const db = new UserDB();
          await db.open();

          const learningData = [
            { prevChar: 'Êòì', to: 'Âú®', from: 'ÂÜç', weight: 1.0 },
            { prevChar: 'Âú®', to: 'Â§ß', from: 'Â§™', weight: 1.0 }
          ];

          await applyLearning(learningData, db);

          const weight1 = await db.getWeight('Êòì', 'Âú®');
          const weight2 = await db.getWeight('Âú®', 'Â§ß');

          expect(weight1).toBeGreaterThan(0);
          expect(weight2).toBeGreaterThan(0);

          await db.close();
        });

        await it('applyLearning should persist across sessions', async () => {
          const db1 = new UserDB();
          await db1.open();

          const learningData = [{
            prevChar: 'Ê∏¨',
            to: 'Ë©¶',
            from: 'Êã≠',
            weight: 2.5
          }];

          await applyLearning(learningData, db1);
          await db1.close();

          // Open new instance (simulate page reload)
          const db2 = new UserDB();
          await db2.open();

          const weight = await db2.getWeight('Ê∏¨', 'Ë©¶');
          expect(weight).toBeGreaterThan(0);

          await db2.close();
        });
      });

      // Suite 5: Learning UI Feedback
      describe('Category 5: Learning UI Feedback (3 tests)', async () => {
        await it('showLearningFeedback function should exist', async () => {
          expect(typeof showLearningFeedback).toBe('function');
        });

        await it('showLearningFeedback should create feedback elements', async () => {
          const learningData = [{
            prevChar: 'Êòì',
            to: 'Âú®',
            from: 'ÂÜç',
            weight: 1.0
          }];

          // Clear any existing feedback
          const existing = document.querySelector('.learning-feedback-container');
          if (existing) existing.remove();

          showLearningFeedback(learningData);

          // Check if feedback container was created
          const container = document.querySelector('.learning-feedback-container');
          expect(container).toBeDefined();

          // Clean up
          if (container) container.remove();
        });

        await it('showLearningFeedback should handle empty learning data', async () => {
          // Should not throw error
          try {
            showLearningFeedback([]);
            expect(true).toBeTruthy();
          } catch (error) {
            throw new Error('showLearningFeedback should handle empty array gracefully');
          }
        });
      });

      // Suite 6: End-to-End Learning Workflow
      describe('Category 6: E2E Learning Workflow (6 tests)', async () => {
        await it('Complete workflow: predict ‚Üí detect ‚Üí apply ‚Üí re-predict', async () => {
          // Use fresh database to ensure predictable initial prediction
          const db = new UserDB('test_e2e_workflow_' + Date.now());
          await db.open();

          // Step 1: Initial prediction (with fresh DB, should be default N-gram choice)
          const result1 = await viterbiWithUserDB(['4jp', 'ad'], mockDayiDb, mockNgramDb, db);
          const prediction = result1.sentence;
          console.log(`[E2E Test] Initial prediction: "${prediction}"`);

          // Step 2: User correction (ensure it's different from prediction)
          // Use opposite of whatever was predicted
          const userSelection = (prediction === 'ÊòìÂú®') ? 'Áæ©ÂÜç' : 'ÊòìÂú®';
          console.log(`[E2E Test] User corrects to: "${userSelection}"`);

          // Step 3: Detect learning
          const learningData = detectLearning(prediction, userSelection);
          expect(learningData.length).toBeGreaterThan(0);

          // Step 4: Apply learning
          await applyLearning(learningData, db);

          // Step 5: Re-predict (should use learned weights)
          const result2 = await viterbiWithUserDB(['4jp', 'ad'], mockDayiDb, mockNgramDb, db);

          // Learned weights should affect result (not necessarily change it completely)
          expect(result2).toBeDefined();

          await db.close();
          await db.deleteDatabase();  // Clean up test database
        });

        await it('Learning should improve prediction accuracy over time', async () => {
          const db = new UserDB();
          await db.open();

          // Simulate user consistently choosing Áæ©‚ÜíÂÜç
          for (let i = 0; i < 5; i++) {
            const learningData = [{
              prevChar: 'Áæ©',
              to: 'ÂÜç',
              from: 'Âú®',
              weight: 1.0
            }];
            await applyLearning(learningData, db);
          }

          const weight = await db.getWeight('Áæ©', 'ÂÜç');
          expect(weight).toBeGreaterThan(4); // Should accumulate

          await db.close();
        });

        await it('Different users should have independent learning', async () => {
          const db1 = new UserDB('user1_webdayi');
          const db2 = new UserDB('user2_webdayi');

          await db1.open();
          await db2.open();

          // User 1 learns preference
          await db1.setWeight('Êòì', 'Âú®', 5.0);

          // User 2 should start fresh
          const weight = await db2.getWeight('Êòì', 'Âú®');
          expect(weight).toBe(0);

          await db1.close();
          await db2.close();
        });

        await it('Export/Import should preserve learned patterns', async () => {
          const db1 = new UserDB();
          await db1.open();

          // Learn some patterns
          await db1.setWeight('Êòì', 'Âú®', 3.5);
          await db1.setWeight('Â§ß', 'Â≠∏', 2.0);

          // Export
          const exported = await db1.getAllWeights();
          expect(Object.keys(exported).length).toBeGreaterThan(0);

          await db1.close();

          // Import to new database
          const db2 = new UserDB('test_import_db');
          await db2.open();
          await db2.importWeights(exported);

          const weight1 = await db2.getWeight('Êòì', 'Âú®');
          const weight2 = await db2.getWeight('Â§ß', 'Â≠∏');

          expect(weight1).toBe(3.5);
          expect(weight2).toBe(2.0);

          await db2.close();
        });

        await it('Learning should handle edge cases gracefully', async () => {
          const db = new UserDB();
          await db.open();

          // Edge case 1: Empty prevChar
          const learningData1 = [{
            prevChar: null,
            to: 'Êòì',
            from: 'Áæ©',
            weight: 1.0
          }];
          await applyLearning(learningData1, db);

          // Edge case 2: Very large weight
          const learningData2 = [{
            prevChar: 'Ê∏¨',
            to: 'Ë©¶',
            from: 'Êã≠',
            weight: 1000.0
          }];
          await applyLearning(learningData2, db);

          const weight = await db.getWeight('Ê∏¨', 'Ë©¶');
          expect(weight).toBeGreaterThan(0);

          await db.close();
        });

        await it('Concurrent learning operations should not corrupt data', async () => {
          const db = new UserDB();
          await db.open();

          // Simulate concurrent writes
          const promises = [];
          for (let i = 0; i < 10; i++) {
            promises.push(db.setWeight('‰∏¶', 'Áôº', i * 0.5));
          }

          await Promise.all(promises);

          // Final weight should be one of the values (last write wins)
          const weight = await db.getWeight('‰∏¶', 'Áôº');
          expect(weight).toBeGreaterThan(0);

          await db.close();
        });
      });

      // Update final summary
      updateSummary();

      // Log detailed test summary to console
      const passed = testResults.filter(t => t.status === 'pass').length;
      const failed = testResults.filter(t => t.status === 'fail').length;
      const total = testResults.length;

      console.log(`\n${'*'.repeat(60)}`);
      console.log(`üèÅ TEST SUMMARY`);
      console.log(`${'*'.repeat(60)}`);
      console.log(`‚úÖ Passed: ${passed}/${total}`);
      console.log(`‚ùå Failed: ${failed}/${total}`);
      console.log(`üìä Success Rate: ${((passed/total)*100).toFixed(1)}%`);

      if (failed > 0) {
        console.log(`\n‚ùå FAILING TESTS:`);
        testResults.filter(t => t.status === 'fail').forEach((test, i) => {
          console.log(`\n${i+1}. ${test.name}`);
          console.log(`   Error: ${test.error}`);
        });
      } else {
        console.log(`\nüéâ ALL TESTS PASSED!`);
      }

      console.log(`${'*'.repeat(60)}\n`);
    }

    // Run all tests when page loads
    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => runAllTests(), 500);
    });
  </script>
</body>
</html>
